# JunoYi 文件管理使用指南

## 概述

JunoYi 文件管理模块提供了统一的文件存储接口，支持多种存储方式：
- 本地存储（Local）
- 阿里云 OSS
- MinIO（待实现）
- 七牛云（待实现）

采用策略模式设计，可以灵活切换存储方式，无需修改业务代码。

## 快速开始

### 1. 配置文件

在 `application.yml` 中配置文件存储：

```yaml
junoyi:
  file:
    # 存储类型：local（本地）、aliyun-oss（阿里云OSS）
    storage-type: local
    # 访问域名（可选）
    domain: http://localhost:8080
    
    # 本地存储配置
    local:
      # 文件存储根路径
      base-path: /data/files
      # URL访问前缀
      url-prefix: /files
    
    # 阿里云OSS配置（使用OSS时需要配置）
    aliyun-oss:
      endpoint: oss-cn-hangzhou.aliyuncs.com
      access-key-id: your-access-key-id
      access-key-secret: your-access-key-secret
      bucket-name: your-bucket-name
      # 自定义域名（可选）
      custom-domain: https://cdn.example.com
```

### 2. 使用上传策略（推荐）

系统内置了多种业务类型的上传策略，可以自动验证文件类型、大小，并按业务分类存储。

#### 2.1 统一上传接口

```java
@RestController
@RequestMapping("/api/file")
@RequiredArgsConstructor
public class FileController {
    
    private final FileHelper fileHelper;
    
    /**
     * 统一文件上传接口
     * 根据业务类型自动应用上传策略
     */
    @PostMapping("/upload")
    public R<FileInfo> upload(
            @RequestParam("file") MultipartFile file,
            @RequestParam("businessType") String businessType) {
        try {
            // 使用策略上传，自动验证和分类
            FileInfo fileInfo = fileHelper.uploadWithStrategy(file, businessType);
            return R.ok(fileInfo);
        } catch (IllegalArgumentException e) {
            // 验证失败
            return R.fail(e.getMessage());
        }
    }
}
```

#### 2.2 业务类型说明

| 业务类型 | 代码 | 允许格式 | 大小限制 | 存储路径 |
|---------|------|---------|---------|---------|
| 用户头像 | avatar | jpg, png, gif, webp | 2MB | avatar/ |
| 文档附件 | document | pdf, doc, docx, xls, xlsx, ppt, pptx, txt | 10MB | document/ |
| 图片文件 | image | jpg, png, webp | 5MB | image/ |
| 视频文件 | video | mp4, mpeg, mov, avi | 100MB | video/ |
| 音频文件 | audio | 不限制 | 20MB | other/ |
| 其他文件 | other | 不限制 | 20MB | other/ |

**说明：**
- **avatar**: 专门用于用户头像，支持 GIF 动图
- **image**: 通用图片类型，适用于商品图片、文章配图、轮播图等场景
- **document**: 办公文档和PDF文件
- **video**: 视频文件
- **audio**: 音频文件（暂用默认策略）
- **other**: 其他类型文件

#### 2.3 前端调用示例

```javascript
// 上传用户头像
const formData = new FormData();
formData.append('file', file);
formData.append('businessType', 'avatar');

axios.post('/api/file/upload', formData)
  .then(response => {
    console.log('上传成功:', response.data.fileUrl);
  })
  .catch(error => {
    console.error('上传失败:', error.response.data.msg);
  });
```

#### 2.4 自定义上传策略

如需自定义业务类型的上传策略，可以实现 `UploadStrategy` 接口：

```java
public class CustomUploadStrategy extends AbstractUploadStrategy {
    
    @Override
    public List<String> getAllowedContentTypes() {
        return Arrays.asList("image/jpeg", "image/png");
    }
    
    @Override
    public List<String> getAllowedExtensions() {
        return Arrays.asList("jpg", "png");
    }
    
    @Override
    public long getMaxFileSize() {
        return 3 * 1024 * 1024; // 3MB
    }
    
    @Override
    public String getPathPrefix() {
        return "custom";
    }
}
```

然后在 `UploadStrategyFactory` 中注册：

```java
STRATEGY_MAP.put(FileBusinessType.CUSTOM, new CustomUploadStrategy());
```

### 3. 使用 FileHelper（灵活方式）

如果不需要策略验证，可以直接使用 `FileHelper` 进行文件操作。

#### 3.1 上传文件

```java
@RestController
@RequestMapping("/api/file")
@RequiredArgsConstructor
public class FileController {
    
    private final FileHelper fileHelper;
    
    /**
     * 上传单个文件
     */
    @PostMapping("/upload")
    public R<FileInfo> upload(@RequestParam("file") MultipartFile file) {
        // 上传到默认路径（按日期自动分类）
        FileInfo fileInfo = fileHelper.upload(file);
        return R.ok(fileInfo);
    }
    
    /**
     * 上传到指定路径
     */
    @PostMapping("/upload-to-path")
    public R<FileInfo> uploadToPath(
            @RequestParam("file") MultipartFile file,
            @RequestParam("path") String path) {
        // 上传到指定路径，如：avatar、document 等
        FileInfo fileInfo = fileHelper.upload(file, path);
        return R.ok(fileInfo);
    }
    
    /**
     * 上传输入流
     */
    @PostMapping("/upload-stream")
    public R<FileInfo> uploadStream(InputStream inputStream) {
        FileInfo fileInfo = fileHelper.upload(
            inputStream, 
            "example.jpg", 
            "images", 
            "image/jpeg"
        );
        return R.ok(fileInfo);
    }
}
```

#### 3.2 下载文件

```java
/**
 * 下载文件
 */
@GetMapping("/download")
public void download(@RequestParam("path") String filePath, 
                     HttpServletResponse response) {
    try {
        byte[] data = fileHelper.download(filePath);
        
        response.setContentType("application/octet-stream");
        response.setHeader("Content-Disposition", 
            "attachment; filename=" + URLEncoder.encode("file.dat", "UTF-8"));
        response.getOutputStream().write(data);
    } catch (IOException e) {
        throw new RuntimeException("文件下载失败", e);
    }
}
```

#### 3.3 删除文件

```java
/**
 * 删除文件
 */
@DeleteMapping("/delete")
public R<Boolean> delete(@RequestParam("path") String filePath) {
    boolean success = fileHelper.delete(filePath);
    return R.ok(success);
}
```

#### 3.4 检查文件是否存在

```java
/**
 * 检查文件是否存在
 */
@GetMapping("/exists")
public R<Boolean> exists(@RequestParam("path") String filePath) {
    boolean exists = fileHelper.exists(filePath);
    return R.ok(exists);
}
```

#### 3.5 获取文件访问URL

```java
/**
 * 获取文件永久访问URL
 */
@GetMapping("/url")
public R<String> getUrl(@RequestParam("path") String filePath) {
    String url = fileHelper.getFileUrl(filePath);
    return R.ok(url);
}

/**
 * 获取文件临时访问URL（带过期时间）
 * 注意：本地存储不支持过期URL，会返回永久URL
 */
@GetMapping("/temp-url")
public R<String> getTempUrl(@RequestParam("path") String filePath) {
    // 生成1小时有效的临时URL
    String url = fileHelper.getFileUrl(filePath, 3600);
    return R.ok(url);
}
```

### 4. 直接使用 FileStorage

如果需要更底层的控制，可以直接注入 `FileStorage` 接口：

```java
@Service
@RequiredArgsConstructor
public class FileService {
    
    private final FileStorage fileStorage;
    
    public FileInfo uploadFile(MultipartFile file) {
        // 直接使用注入的存储实例
        return fileStorage.upload(file, "custom-path");
    }
}
```

## FileInfo 对象说明

上传成功后返回的 `FileInfo` 对象包含以下信息：

```java
public class FileInfo {
    private String originalName;    // 原始文件名
    private String storageName;     // 存储文件名（UUID）
    private String filePath;        // 文件存储路径
    private String fileUrl;         // 文件访问URL
    private Long fileSize;          // 文件大小（字节）
    private String contentType;     // 文件MIME类型
    private String extension;       // 文件扩展名
    private String storageType;     // 存储类型
    private String md5;             // 文件MD5值（本地存储）
    private LocalDateTime uploadTime; // 上传时间
}
```

## 存储类型说明

### 本地存储（Local）

**优点：**
- 简单易用，无需额外配置
- 适合开发环境和小型应用
- 无额外费用

**缺点：**
- 不支持分布式部署
- 需要定期备份
- 带宽受限于服务器

**配置示例：**
```yaml
junoyi:
  file:
    storage-type: local
    local:
      base-path: /data/files
      url-prefix: /files
```

**注意事项：**
- 系统已自动配置静态资源映射，文件可以通过HTTP访问
- URL格式：`{domain}{url-prefix}/{filePath}`，例如：`http://localhost:8080/files/avatar/2026/01/20/xxx.jpg`
- 建议定期备份文件目录
- 生产环境建议使用云存储

### 阿里云 OSS

**优点：**
- 高可用、高并发
- 支持CDN加速
- 自动备份和容灾
- 支持临时访问URL

**缺点：**
- 需要付费
- 需要配置访问密钥

**配置示例：**
```yaml
junoyi:
  file:
    storage-type: aliyun-oss
    aliyun-oss:
      endpoint: oss-cn-hangzhou.aliyuncs.com
      access-key-id: ${ALIYUN_ACCESS_KEY_ID}
      access-key-secret: ${ALIYUN_ACCESS_KEY_SECRET}
      bucket-name: my-bucket
      custom-domain: https://cdn.example.com
```

**注意事项：**
- 建议使用环境变量存储密钥，不要硬编码
- 需要在阿里云控制台创建Bucket
- 如果使用自定义域名，需要配置CNAME解析

## 文件路径规范

系统会自动按业务类型和日期组织文件目录结构：

```
{base-path}/
  └── {business-type}/
      └── {year}/
          └── {month}/
              └── {day}/
                  └── {uuid}.{extension}
```

例如：
```
/data/files/avatar/2026/01/20/a1b2c3d4.jpg
/data/files/document/2026/01/20/e5f6g7h8.pdf
/data/files/image/2026/01/20/f9g0h1i2.png
/data/files/other/2026/01/20/j3k4l5m6.zip
```

**说明：**
- 使用策略上传时，自动使用策略定义的业务类型路径
- 不使用策略上传时，默认存储到 `other` 目录
- 每个业务类型下按日期（年/月/日）自动分类
- 文件名使用 UUID 确保唯一性

## 最佳实践

### 1. 环境隔离

不同环境使用不同的存储配置：

```yaml
# application-dev.yml（开发环境）
junoyi:
  file:
    storage-type: local
    local:
      base-path: ./upload

# application-prod.yml（生产环境）
junoyi:
  file:
    storage-type: aliyun-oss
    aliyun-oss:
      endpoint: ${OSS_ENDPOINT}
      access-key-id: ${OSS_ACCESS_KEY_ID}
      access-key-secret: ${OSS_ACCESS_KEY_SECRET}
      bucket-name: ${OSS_BUCKET_NAME}
```

### 2. 选择合适的上传方式

**方式1：使用策略上传（推荐）**
- 适用场景：需要严格控制文件类型和大小的业务场景
- 优点：自动验证、规范化存储、防止恶意文件
- 示例：用户头像、商品图片、文档附件等

```java
fileHelper.uploadWithStrategy(file, "avatar");  // 严格验证图片格式和大小
```

**方式2：智能检测上传**
- 适用场景：文件类型多样但需要自动分类的场景
- 优点：自动分类、无需手动指定、灵活方便
- 示例：用户上传的各类文件、临时文件等

```java
fileHelper.upload(file);  // 自动检测并分类存储
```

**方式3：手动指定路径**
- 适用场景：特殊业务需求、自定义分类
- 优点：完全自定义、灵活性最高
- 示例：特定业务模块的文件、临时文件等

```java
fileHelper.upload(file, "custom-path");  // 存储到自定义路径
```

### 3. 文件分类存储（智能检测）

如果不使用策略，系统会根据文件类型自动检测并分类存储：

```java
// 自动检测文件类型并分类存储
fileHelper.upload(file);

// 示例：
// - 上传 image.jpg  → 自动存储到 image/2026/01/20/xxx.jpg
// - 上传 video.mp4  → 自动存储到 video/2026/01/20/xxx.mp4
// - 上传 doc.pdf    → 自动存储到 document/2026/01/20/xxx.pdf
// - 上传 music.mp3  → 自动存储到 audio/2026/01/20/xxx.mp3
// - 上传 file.zip   → 自动存储到 other/2026/01/20/xxx.zip

// 也可以手动指定业务类型路径
fileHelper.upload(file, "avatar");    // 存储到 avatar/2026/01/20/xxx.jpg
fileHelper.upload(file, "custom");    // 存储到 custom/2026/01/20/xxx.jpg
```

**文件类型自动检测规则：**
- **图片文件**：jpg、png、gif、webp、bmp、svg 等 → `image` 目录
- **视频文件**：mp4、avi、mov、mkv、flv 等 → `video` 目录
- **音频文件**：mp3、wav、flac、aac、ogg 等 → `audio` 目录
- **文档文件**：pdf、doc、docx、xls、xlsx、ppt、pptx、txt 等 → `document` 目录
- **其他文件**：无法识别的文件类型 → `other` 目录

**注意：** 
- 智能检测基于文件的 MIME 类型和扩展名
- 不会进行文件大小和格式验证
- 如需验证，建议使用策略上传

### 3. 文件大小限制

在 Spring Boot 配置中限制上传文件大小：

```yaml
spring:
  servlet:
    multipart:
      max-file-size: 10MB
      max-request-size: 10MB
```

### 4. 文件类型验证

使用上传策略时会自动验证文件类型，也可以在业务代码中手动验证：

```java
public FileInfo uploadAvatar(MultipartFile file) {
    // 使用策略自动验证
    return fileHelper.uploadWithStrategy(file, FileBusinessType.AVATAR);
}

// 或者手动验证
public FileInfo uploadAvatarManual(MultipartFile file) {
    // 验证文件类型
    String contentType = file.getContentType();
    if (!contentType.startsWith("image/")) {
        throw new BusinessException("只能上传图片文件");
    }
    
    // 验证文件大小
    if (file.getSize() > 2 * 1024 * 1024) {
        throw new BusinessException("图片大小不能超过2MB");
    }
    
    return fileHelper.upload(file, "avatar");
}
```

### 5. 数据库记录

建议在数据库中记录文件信息：

```sql
CREATE TABLE sys_file (
    id BIGINT PRIMARY KEY AUTO_INCREMENT,
    original_name VARCHAR(255) COMMENT '原始文件名',
    storage_name VARCHAR(255) COMMENT '存储文件名',
    file_path VARCHAR(500) COMMENT '文件路径',
    file_url VARCHAR(500) COMMENT '访问URL',
    file_size BIGINT COMMENT '文件大小',
    content_type VARCHAR(100) COMMENT '文件类型',
    extension VARCHAR(20) COMMENT '文件扩展名',
    storage_type VARCHAR(20) COMMENT '存储类型',
    md5 VARCHAR(32) COMMENT 'MD5值',
    upload_user_id BIGINT COMMENT '上传用户ID',
    upload_time DATETIME COMMENT '上传时间',
    deleted TINYINT DEFAULT 0 COMMENT '是否删除'
);
```

## 扩展其他存储方式

如需支持MinIO、七牛云等其他存储方式，可以实现 `FileStorage` 接口：

```java
public class MinioFileStorage implements FileStorage {
    
    @Override
    public FileInfo upload(MultipartFile file, String path) {
        // 实现MinIO上传逻辑
    }
    
    @Override
    public byte[] download(String filePath) {
        // 实现MinIO下载逻辑
    }
    
    // ... 实现其他方法
}
```

然后在 `FileStorageFactory` 中注册：

```java
@Bean
@ConditionalOnProperty(name = "junoyi.file.storage-type", havingValue = "minio")
public FileStorage minioFileStorage(FileStorageProperties properties) {
    return new MinioFileStorage(properties);
}
```

## 常见问题

### Q1: 本地存储的文件无法访问？

A: 系统已自动配置静态资源映射，无需手动配置。如果仍无法访问，请检查：
1. 配置的 `url-prefix` 是否正确（默认为 `/files`）
2. 配置的 `base-path` 路径是否存在且有读写权限
3. 文件路径是否正确，可以通过 `FileInfo.fileUrl` 获取完整访问URL
4. 如果使用了反向代理（如Nginx），需要配置相应的路由规则

### Q2: 如何切换存储方式？

A: 只需修改配置文件中的 `storage-type` 即可，无需修改代码：

```yaml
junoyi:
  file:
    storage-type: aliyun-oss  # 从 local 改为 aliyun-oss
```

### Q3: 如何实现文件秒传？

A: 可以通过MD5值判断文件是否已存在：

```java
public FileInfo uploadWithDeduplication(MultipartFile file) {
    // 计算MD5
    String md5 = MD5.create().digestHex(file.getBytes());
    
    // 查询数据库是否已存在相同MD5的文件
    FileInfo existingFile = fileMapper.selectByMd5(md5);
    if (existingFile != null) {
        return existingFile; // 秒传
    }
    
    // 不存在则上传
    return fileHelper.upload(file);
}
```

### Q4: 如何实现断点续传？

A: 需要使用分片上传，建议使用OSS的分片上传API，本地存储不支持断点续传。

## 总结

JunoYi 文件管理模块提供了简单、统一、可扩展的文件存储解决方案。通过配置即可切换不同的存储方式，满足不同场景的需求。

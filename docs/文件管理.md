# JunoYi 文件管理使用指南

## 概述

JunoYi 文件管理模块提供了统一的文件存储接口，支持多种存储方式：
- 本地存储（Local）
- 阿里云 OSS
- MinIO（待实现）
- 七牛云（待实现）

采用策略模式设计，可以灵活切换存储方式，无需修改业务代码。

## 快速开始

### 1. 配置文件

在 `application.yml` 中配置文件存储：

```yaml
junoyi:
  file:
    # 存储类型：local（本地）、aliyun-oss（阿里云OSS）
    storage-type: local
    # 访问域名（可选）
    domain: http://localhost:8080
    
    # 本地存储配置
    local:
      # 文件存储根路径
      base-path: /data/files
      # URL访问前缀
      url-prefix: /files
    
    # 阿里云OSS配置（使用OSS时需要配置）
    aliyun-oss:
      endpoint: oss-cn-hangzhou.aliyuncs.com
      access-key-id: your-access-key-id
      access-key-secret: your-access-key-secret
      bucket-name: your-bucket-name
      # 自定义域名（可选）
      custom-domain: https://cdn.example.com
```

### 2. 使用 FileHelper

`FileHelper` 是文件操作的统一入口，提供了简单易用的API。

#### 2.1 上传文件

```java
@RestController
@RequestMapping("/api/file")
@RequiredArgsConstructor
public class FileController {
    
    private final FileHelper fileHelper;
    
    /**
     * 上传单个文件
     */
    @PostMapping("/upload")
    public R<FileInfo> upload(@RequestParam("file") MultipartFile file) {
        // 上传到默认路径（按日期自动分类）
        FileInfo fileInfo = fileHelper.upload(file);
        return R.ok(fileInfo);
    }
    
    /**
     * 上传到指定路径
     */
    @PostMapping("/upload-to-path")
    public R<FileInfo> uploadToPath(
            @RequestParam("file") MultipartFile file,
            @RequestParam("path") String path) {
        // 上传到指定路径，如：avatar、document 等
        FileInfo fileInfo = fileHelper.upload(file, path);
        return R.ok(fileInfo);
    }
    
    /**
     * 上传输入流
     */
    @PostMapping("/upload-stream")
    public R<FileInfo> uploadStream(InputStream inputStream) {
        FileInfo fileInfo = fileHelper.upload(
            inputStream, 
            "example.jpg", 
            "images", 
            "image/jpeg"
        );
        return R.ok(fileInfo);
    }
}
```

#### 2.2 下载文件

```java
/**
 * 下载文件
 */
@GetMapping("/download")
public void download(@RequestParam("path") String filePath, 
                     HttpServletResponse response) {
    try {
        byte[] data = fileHelper.download(filePath);
        
        response.setContentType("application/octet-stream");
        response.setHeader("Content-Disposition", 
            "attachment; filename=" + URLEncoder.encode("file.dat", "UTF-8"));
        response.getOutputStream().write(data);
    } catch (IOException e) {
        throw new RuntimeException("文件下载失败", e);
    }
}
```

#### 2.3 删除文件

```java
/**
 * 删除文件
 */
@DeleteMapping("/delete")
public R<Boolean> delete(@RequestParam("path") String filePath) {
    boolean success = fileHelper.delete(filePath);
    return R.ok(success);
}
```

#### 2.4 检查文件是否存在

```java
/**
 * 检查文件是否存在
 */
@GetMapping("/exists")
public R<Boolean> exists(@RequestParam("path") String filePath) {
    boolean exists = fileHelper.exists(filePath);
    return R.ok(exists);
}
```

#### 2.5 获取文件访问URL

```java
/**
 * 获取文件永久访问URL
 */
@GetMapping("/url")
public R<String> getUrl(@RequestParam("path") String filePath) {
    String url = fileHelper.getFileUrl(filePath);
    return R.ok(url);
}

/**
 * 获取文件临时访问URL（带过期时间）
 * 注意：本地存储不支持过期URL，会返回永久URL
 */
@GetMapping("/temp-url")
public R<String> getTempUrl(@RequestParam("path") String filePath) {
    // 生成1小时有效的临时URL
    String url = fileHelper.getFileUrl(filePath, 3600);
    return R.ok(url);
}
```

### 3. 直接使用 FileStorage

如果需要更底层的控制，可以直接注入 `FileStorage` 接口：

```java
@Service
@RequiredArgsConstructor
public class FileService {
    
    private final FileStorage fileStorage;
    
    public FileInfo uploadFile(MultipartFile file) {
        // 直接使用注入的存储实例
        return fileStorage.upload(file, "custom-path");
    }
}
```

## FileInfo 对象说明

上传成功后返回的 `FileInfo` 对象包含以下信息：

```java
public class FileInfo {
    private String originalName;    // 原始文件名
    private String storageName;     // 存储文件名（UUID）
    private String filePath;        // 文件存储路径
    private String fileUrl;         // 文件访问URL
    private Long fileSize;          // 文件大小（字节）
    private String contentType;     // 文件MIME类型
    private String extension;       // 文件扩展名
    private String storageType;     // 存储类型
    private String md5;             // 文件MD5值（本地存储）
    private LocalDateTime uploadTime; // 上传时间
}
```

## 存储类型说明

### 本地存储（Local）

**优点：**
- 简单易用，无需额外配置
- 适合开发环境和小型应用
- 无额外费用

**缺点：**
- 不支持分布式部署
- 需要定期备份
- 带宽受限于服务器

**配置示例：**
```yaml
junoyi:
  file:
    storage-type: local
    local:
      base-path: /data/files
      url-prefix: /files
```

**注意事项：**
- 系统已自动配置静态资源映射，文件可以通过HTTP访问
- URL格式：`{domain}{url-prefix}/{filePath}`，例如：`http://localhost:8080/files/avatar/2026/01/20/xxx.jpg`
- 建议定期备份文件目录
- 生产环境建议使用云存储

### 阿里云 OSS

**优点：**
- 高可用、高并发
- 支持CDN加速
- 自动备份和容灾
- 支持临时访问URL

**缺点：**
- 需要付费
- 需要配置访问密钥

**配置示例：**
```yaml
junoyi:
  file:
    storage-type: aliyun-oss
    aliyun-oss:
      endpoint: oss-cn-hangzhou.aliyuncs.com
      access-key-id: ${ALIYUN_ACCESS_KEY_ID}
      access-key-secret: ${ALIYUN_ACCESS_KEY_SECRET}
      bucket-name: my-bucket
      custom-domain: https://cdn.example.com
```

**注意事项：**
- 建议使用环境变量存储密钥，不要硬编码
- 需要在阿里云控制台创建Bucket
- 如果使用自定义域名，需要配置CNAME解析

## 文件路径规范

系统会自动按日期组织文件目录结构：

```
{base-path}/
  └── {custom-path}/
      └── {year}/
          └── {month}/
              └── {day}/
                  └── {uuid}.{extension}
```

例如：
```
/data/files/avatar/2026/01/20/a1b2c3d4.jpg
/data/files/document/2026/01/20/e5f6g7h8.pdf
```

## 最佳实践

### 1. 环境隔离

不同环境使用不同的存储配置：

```yaml
# application-dev.yml（开发环境）
junoyi:
  file:
    storage-type: local
    local:
      base-path: ./upload

# application-prod.yml（生产环境）
junoyi:
  file:
    storage-type: aliyun-oss
    aliyun-oss:
      endpoint: ${OSS_ENDPOINT}
      access-key-id: ${OSS_ACCESS_KEY_ID}
      access-key-secret: ${OSS_ACCESS_KEY_SECRET}
      bucket-name: ${OSS_BUCKET_NAME}
```

### 2. 文件分类存储

根据业务类型使用不同的路径：

```java
// 用户头像
fileHelper.upload(file, "avatar");

// 文档附件
fileHelper.upload(file, "document");

// 商品图片
fileHelper.upload(file, "product");
```

### 3. 文件大小限制

在 Spring Boot 配置中限制上传文件大小：

```yaml
spring:
  servlet:
    multipart:
      max-file-size: 10MB
      max-request-size: 10MB
```

### 4. 文件类型验证

在业务代码中验证文件类型：

```java
public FileInfo uploadAvatar(MultipartFile file) {
    // 验证文件类型
    String contentType = file.getContentType();
    if (!contentType.startsWith("image/")) {
        throw new BusinessException("只能上传图片文件");
    }
    
    // 验证文件大小
    if (file.getSize() > 2 * 1024 * 1024) {
        throw new BusinessException("图片大小不能超过2MB");
    }
    
    return fileHelper.upload(file, "avatar");
}
```

### 5. 数据库记录

建议在数据库中记录文件信息：

```sql
CREATE TABLE sys_file (
    id BIGINT PRIMARY KEY AUTO_INCREMENT,
    original_name VARCHAR(255) COMMENT '原始文件名',
    storage_name VARCHAR(255) COMMENT '存储文件名',
    file_path VARCHAR(500) COMMENT '文件路径',
    file_url VARCHAR(500) COMMENT '访问URL',
    file_size BIGINT COMMENT '文件大小',
    content_type VARCHAR(100) COMMENT '文件类型',
    extension VARCHAR(20) COMMENT '文件扩展名',
    storage_type VARCHAR(20) COMMENT '存储类型',
    md5 VARCHAR(32) COMMENT 'MD5值',
    upload_user_id BIGINT COMMENT '上传用户ID',
    upload_time DATETIME COMMENT '上传时间',
    deleted TINYINT DEFAULT 0 COMMENT '是否删除'
);
```

## 扩展其他存储方式

如需支持MinIO、七牛云等其他存储方式，可以实现 `FileStorage` 接口：

```java
public class MinioFileStorage implements FileStorage {
    
    @Override
    public FileInfo upload(MultipartFile file, String path) {
        // 实现MinIO上传逻辑
    }
    
    @Override
    public byte[] download(String filePath) {
        // 实现MinIO下载逻辑
    }
    
    // ... 实现其他方法
}
```

然后在 `FileStorageFactory` 中注册：

```java
@Bean
@ConditionalOnProperty(name = "junoyi.file.storage-type", havingValue = "minio")
public FileStorage minioFileStorage(FileStorageProperties properties) {
    return new MinioFileStorage(properties);
}
```

## 常见问题

### Q1: 本地存储的文件无法访问？

A: 系统已自动配置静态资源映射，无需手动配置。如果仍无法访问，请检查：
1. 配置的 `url-prefix` 是否正确（默认为 `/files`）
2. 配置的 `base-path` 路径是否存在且有读写权限
3. 文件路径是否正确，可以通过 `FileInfo.fileUrl` 获取完整访问URL
4. 如果使用了反向代理（如Nginx），需要配置相应的路由规则

### Q2: 如何切换存储方式？

A: 只需修改配置文件中的 `storage-type` 即可，无需修改代码：

```yaml
junoyi:
  file:
    storage-type: aliyun-oss  # 从 local 改为 aliyun-oss
```

### Q3: 如何实现文件秒传？

A: 可以通过MD5值判断文件是否已存在：

```java
public FileInfo uploadWithDeduplication(MultipartFile file) {
    // 计算MD5
    String md5 = MD5.create().digestHex(file.getBytes());
    
    // 查询数据库是否已存在相同MD5的文件
    FileInfo existingFile = fileMapper.selectByMd5(md5);
    if (existingFile != null) {
        return existingFile; // 秒传
    }
    
    // 不存在则上传
    return fileHelper.upload(file);
}
```

### Q4: 如何实现断点续传？

A: 需要使用分片上传，建议使用OSS的分片上传API，本地存储不支持断点续传。

## 总结

JunoYi 文件管理模块提供了简单、统一、可扩展的文件存储解决方案。通过配置即可切换不同的存储方式，满足不同场景的需求。
